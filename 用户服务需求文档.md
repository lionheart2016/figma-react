# 全局用户服务需求说明文档及执行计划

## 1. 需求概述

开发一套全局用户服务系统，支持用户未登录状态与已登录状态的管理，集成Privy SDK实现用户认证和登录功能，并能够在完成注册及认证流程后自动触发用户登录操作。

## 2. 功能需求

### 2.1 用户认证管理
- 支持用户登录与登出操作
- 支持邮箱验证码登录方式（默认）
- 支持用户会话状态管理
- 支持获取当前用户信息

### 2.2 全局用户状态
- 维护全局用户登录状态（已登录/未登录）
- 提供用户状态变更的监听机制
- 在应用启动时自动检测用户登录状态

### 2.3 集成Privy SDK
- 使用Privy SDK进行用户认证
- 支持邮箱验证码登录流程
- 支持后续扩展其他登录方式（如SMS、OAuth等）

### 2.4 与现有系统集成
- 与现有路由系统集成，支持根据用户状态控制路由访问
- 与国际化系统集成，确保错误提示和界面文本支持多语言


### 3.3 可用性
- 提供友好的错误处理和用户提示
- 支持测试账号快速登录：test-1143@privy.io，验证码：894575

## 4. 技术方案

### 4.1 架构设计
- 创建全局用户上下文（UserContext）管理用户状态
- 通过PrivyProvider包装应用，提供认证功能
- 实现用户服务（UserService）封装Privy SDK操作
- 在路由系统中集成用户状态检查

### 4.2 核心组件

#### 4.2.1 用户上下文（UserContext）
- 维护全局用户状态
- 提供用户登录/登出/获取用户信息等方法
- 支持状态变更通知

#### 4.2.2 用户服务（UserService）
- 封装Privy SDK的具体调用
- 处理认证流程中的错误和异常
- 提供统一的接口给应用其他部分使用



#### 4.2.4 认证路由保护（ProtectedRoute）
- 根据用户登录状态控制路由访问权限
- 未登录用户自动重定向至登录页面

## 5. 执行计划

### 5.1 阶段一：环境准备与依赖安装（1天）

**任务1.1**：安装Privy SDK依赖
```bash
yarn add @privy-io/react-auth
```

### 5.2 阶段二：核心服务实现（2天）

**任务2.1**：创建Privy Provider
- 在应用入口处添加PrivyProvider
- 配置必要的参数

**任务2.2**：实现UserContext上下文
- 创建用户状态管理的React上下文
- 实现用户状态相关的方法和状态管理

### 5.3 阶段三：UI组件开发（2天）

**任务3.1**：实现登录组件
- 创建邮箱验证码登录界面
- 集成国际化支持

**任务3.2**：实现认证路由保护
- 创建ProtectedRoute组件
- 集成到现有路由系统

### 5.4 阶段四：系统集成与测试（1天）

**任务4.1**：系统集成
- 将用户服务与现有应用集成
- 确保各个组件协同工作正常

**任务4.2**：测试
- 使用测试账号验证登录流程
- 测试状态管理和路由保护功能

## 6. 代码实现细节

### 6.1 Privy Provider配置

参照whitelabel-starter项目，在应用入口处配置PrivyProvider：

```tsx
// src/providers/PrivyProvider.tsx
import { PrivyProvider as BasePrivyProvider } from '@privy-io/react-auth';
import { baseSepolia } from 'viem/chains';

interface PrivyProviderProps {
  children: React.ReactNode;
}

export const PrivyProvider: React.FC<PrivyProviderProps> = ({ children }) => {
  return (
    <BasePrivyProvider
      appId={import.meta.env.VITE_PRIVY_APP_ID}
      config={{
        appearance: { theme: 'light', walletChainType: 'ethereum-and-solana' },
        defaultChain: baseSepolia,
        embeddedWallets: {
          createOnLogin: 'off',
          showWalletUIs: false,
        },
        mfa: {
          noPromptOnMfaRequired: true,
        },
      }}
    >
      {children}
    </BasePrivyProvider>
  );
};
```

### 6.2 用户上下文实现

```tsx
// src/contexts/UserContext.tsx
import { createContext, useContext, ReactNode, useEffect, useState } from 'react';
import { usePrivy, useLoginWithEmail } from '@privy-io/react-auth';

interface User {
  id: string;
  email?: string;
  // 其他用户信息字段
}

interface UserContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  sendEmailCode: (email: string) => Promise<void>;
  loginWithCode: (code: string) => Promise<void>;
  logout: () => Promise<void>;
}

const UserContext = createContext<UserContextType | undefined>(undefined);

export const useUser = () => {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
};

interface UserProviderProps {
  children: ReactNode;
}

export const UserProvider: React.FC<UserProviderProps> = ({ children }) => {
  const { ready, authenticated, user, logout: privyLogout } = usePrivy();
  const { sendCode, loginWithCode, state } = useLoginWithEmail({
    onComplete: ({ user, isNewUser, wasAlreadyAuthenticated, loginMethod }) => {
      console.log('User successfully logged in', { user, isNewUser, wasAlreadyAuthenticated, loginMethod });
    },
    onError: (error) => {
      console.error('Login error:', error);
      setError(error?.message || 'Failed to login');
    },
  });

  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (ready) {
      setIsLoading(false);
    }
  }, [ready]);

  const sendEmailCode = async (email: string) => {
    setError(null);
    try {
      await sendCode({ email });
    } catch (err) {
      setError('Failed to send verification code');
      throw err;
    }
  };

  const loginWithCodeHandler = async (code: string) => {
    setError(null);
    setIsLoading(true);
    try {
      await loginWithCode({ code });
    } catch (err) {
      setError('Invalid verification code');
      throw err;
    } finally {
      setIsLoading(false);
    }
  };

  const logoutHandler = async () => {
    setIsLoading(true);
    try {
      await privyLogout();
    } catch (err) {
      setError('Failed to logout');
      throw err;
    } finally {
      setIsLoading(false);
    }
  };

  const value: UserContextType = {
    user: user ? { id: user.id, email: user.email } : null,
    isAuthenticated: authenticated,
    isLoading,
    error,
    sendEmailCode,
    loginWithCode: loginWithCodeHandler,
    logout: logoutHandler,
  };

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
};
```

### 6.3 应用入口修改

```tsx
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import { initI18n } from './config/i18n';
import { PrivyProvider } from './providers/PrivyProvider';
import { UserProvider } from './contexts/UserContext';

// 初始化i18n然后渲染React应用
initI18n().then(() => {
  const rootElement = document.getElementById('root');
  if (rootElement) {
    ReactDOM.createRoot(rootElement).render(
      <React.StrictMode>
        <PrivyProvider>
          <UserProvider>
            <App />
          </UserProvider>
        </PrivyProvider>
      </React.StrictMode>,
    );
  }
}).catch(error => {
  console.error('Failed to initialize i18n:', error);
  // 即使i18n初始化失败，也渲染应用
  const rootElement = document.getElementById('root');
  if (rootElement) {
    ReactDOM.createRoot(rootElement).render(
      <React.StrictMode>
        <PrivyProvider>
          <UserProvider>
            <App />
          </UserProvider>
        </PrivyProvider>
      </React.StrictMode>,
    );
  }
});
```

### 6.4 登录组件实现

```tsx
// src/components/auth-module/Login.tsx
import React, { useState } from 'react';
import { useUser } from '../../contexts/UserContext';
import { useTranslation } from 'react-i18next';

const Login: React.FC = () => {
  const { t } = useTranslation();
  const { sendEmailCode, loginWithCode, isLoading, error } = useUser();
  
  const [email, setEmail] = useState('');
  const [code, setCode] = useState('');
  const [step, setStep] = useState<'email' | 'code'>('email');
  const [emailSent, setEmailSent] = useState(false);

  const handleSendCode = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!email) return;
    
    try {
      await sendEmailCode(email);
      setEmailSent(true);
      setStep('code');
    } catch (err) {
      // 错误已在context中处理
    }
  };

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!code) return;
    
    try {
      await loginWithCode(code);
      // 登录成功后会自动更新用户状态
    } catch (err) {
      // 错误已在context中处理
    }
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen p-4">
      <div className="w-full max-w-md">
        <h1 className="text-2xl font-bold text-center mb-6">{t('login.title')}</h1>
        
        {error && (
          <div className="mb-4 p-3 bg-red-100 text-red-700 rounded">
            {error}
          </div>
        )}

        {step === 'email' ? (
          <form onSubmit={handleSendCode}>
            <div className="mb-4">
              <label htmlFor="email" className="block text-sm font-medium mb-1">
                {t('login.email')}
              </label>
              <input
                type="email"
                id="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="your@email.com"
                className="w-full px-4 py-2 border rounded"
                required
              />
            </div>
            
            <button 
              type="submit" 
              className="w-full bg-blue-500 text-white py-2 rounded hover:bg-blue-600"
              disabled={isLoading}
            >
              {isLoading ? t('login.sending') : t('login.sendCode')}
            </button>
            
            <div className="mt-4 text-center text-sm text-gray-500">
              <p>{t('login.testAccount')}: test-1143@privy.io</p>
              <p>{t('login.testCode')}: 894575</p>
            </div>
          </form>
        ) : (
          <form onSubmit={handleLogin}>
            <div className="mb-4">
              <label htmlFor="code" className="block text-sm font-medium mb-1">
                {t('login.verificationCode')}
              </label>
              <input
                type="text"
                id="code"
                value={code}
                onChange={(e) => setCode(e.target.value)}
                placeholder="123456"
                className="w-full px-4 py-2 border rounded"
                required
                maxLength={6}
              />
            </div>
            
            <button 
              type="submit" 
              className="w-full bg-blue-500 text-white py-2 rounded hover:bg-blue-600"
              disabled={isLoading}
            >
              {isLoading ? t('login.loggingIn') : t('login.login')}
            </button>
            
            <button 
              type="button" 
              onClick={() => {
                setStep('email');
                setCode('');
                setEmailSent(false);
              }}
              className="w-full mt-2 text-blue-500"
            >
              {t('login.changeEmail')}
            </button>
          </form>
        )}
      </div>
    </div>
  );
};

export default Login;
```

### 6.5 认证路由保护实现

```tsx
// src/components/auth-module/ProtectedRoute.tsx
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useUser } from '../../contexts/UserContext';

interface ProtectedRouteProps {
  redirectPath?: string;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  redirectPath = '/login' 
}) => {
  const { isAuthenticated, isLoading } = useUser();
  const location = useLocation();

  if (isLoading) {
    return <div>Loading...</div>; // 或者显示一个加载指示器
  }

  if (!isAuthenticated) {
    return <Navigate to={redirectPath} state={{ from: location }} replace />;
  }

  return <Outlet />;
};

export default ProtectedRoute;
```

## 7. 国际化配置

需要在国际化文件中添加以下翻译条目：

```json
// src/locales/en.json
{
  "login": {
    "title": "Sign In",
    "email": "Email Address",
    "verificationCode": "Verification Code",
    "sendCode": "Send Verification Code",
    "login": "Sign In",
    "sending": "Sending...",
    "loggingIn": "Signing in...",
    "changeEmail": "Change Email",
    "testAccount": "Test Account",
    "testCode": "Test Verification Code"
  }
}
```

## 8. 总结

本需求文档和执行计划详细描述了全局用户服务的开发方案，包括用户认证管理、全局用户状态维护、Privy SDK集成以及与现有系统的整合。通过实施该计划，可以在6个工作日内完成全局用户服务的开发和集成，实现用户登录状态的全局管理，并确保系统的安全性、可用性和性能符合要求。