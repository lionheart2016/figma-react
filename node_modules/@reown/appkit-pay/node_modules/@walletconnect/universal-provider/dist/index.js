import{SignClient as je}from"@walletconnect/sign-client";import{isValidObject as P,isCaipNamespace as V,parseNamespaceKey as O,mergeArrays as D,parseChainId as I,calcExpiry as Ne,isExpired as Y,createLogger as qe,getSdkError as X,isValidArray as R}from"@walletconnect/utils";import{formatJsonRpcRequest as k,formatJsonRpcResult as De}from"@walletconnect/jsonrpc-utils";import{JsonRpcProvider as Q}from"@walletconnect/jsonrpc-provider";import Re,{HttpConnection as _e}from"@walletconnect/jsonrpc-http-connection";import xe from"events";function _(t){return t==null||typeof t!="object"&&typeof t!="function"}function Z(t){return Object.getOwnPropertySymbols(t).filter(e=>Object.prototype.propertyIsEnumerable.call(t,e))}function T(t){return t==null?t===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(t)}const Fe="[object RegExp]",ee="[object String]",te="[object Number]",se="[object Boolean]",ie="[object Arguments]",He="[object Symbol]",Ue="[object Date]",Be="[object Map]",Le="[object Set]",Me="[object Array]",ze="[object ArrayBuffer]",Ge="[object Object]",We="[object DataView]",Je="[object Uint8Array]",Ke="[object Uint8ClampedArray]",Ve="[object Uint16Array]",Ye="[object Uint32Array]",Xe="[object Int8Array]",ke="[object Int16Array]",Qe="[object Int32Array]",Ze="[object Float32Array]",Te="[object Float64Array]";function x(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function et(t,e){return y(t,void 0,t,new Map,e)}function y(t,e,s,i=new Map,r=void 0){const a=r?.(t,e,s,i);if(a!=null)return a;if(_(t))return t;if(i.has(t))return i.get(t);if(Array.isArray(t)){const n=new Array(t.length);i.set(t,n);for(let c=0;c<t.length;c++)n[c]=y(t[c],c,s,i,r);return Object.hasOwn(t,"index")&&(n.index=t.index),Object.hasOwn(t,"input")&&(n.input=t.input),n}if(t instanceof Date)return new Date(t.getTime());if(t instanceof RegExp){const n=new RegExp(t.source,t.flags);return n.lastIndex=t.lastIndex,n}if(t instanceof Map){const n=new Map;i.set(t,n);for(const[c,o]of t)n.set(c,y(o,c,s,i,r));return n}if(t instanceof Set){const n=new Set;i.set(t,n);for(const c of t)n.add(y(c,void 0,s,i,r));return n}if(typeof Buffer<"u"&&Buffer.isBuffer(t))return t.subarray();if(x(t)){const n=new(Object.getPrototypeOf(t)).constructor(t.length);i.set(t,n);for(let c=0;c<t.length;c++)n[c]=y(t[c],c,s,i,r);return n}if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer)return t.slice(0);if(t instanceof DataView){const n=new DataView(t.buffer.slice(0),t.byteOffset,t.byteLength);return i.set(t,n),m(n,t,s,i,r),n}if(typeof File<"u"&&t instanceof File){const n=new File([t],t.name,{type:t.type});return i.set(t,n),m(n,t,s,i,r),n}if(t instanceof Blob){const n=new Blob([t],{type:t.type});return i.set(t,n),m(n,t,s,i,r),n}if(t instanceof Error){const n=new t.constructor;return i.set(t,n),n.message=t.message,n.name=t.name,n.stack=t.stack,n.cause=t.cause,m(n,t,s,i,r),n}if(typeof t=="object"&&tt(t)){const n=Object.create(Object.getPrototypeOf(t));return i.set(t,n),m(n,t,s,i,r),n}return t}function m(t,e,s=t,i,r){const a=[...Object.keys(e),...Z(e)];for(let n=0;n<a.length;n++){const c=a[n],o=Object.getOwnPropertyDescriptor(t,c);(o==null||o.writable)&&(t[c]=y(e[c],c,s,i,r))}}function tt(t){switch(T(t)){case ie:case Me:case ze:case We:case se:case Ue:case Ze:case Te:case Xe:case ke:case Qe:case Be:case te:case Ge:case Fe:case Le:case ee:case He:case Je:case Ke:case Ve:case Ye:return!0;default:return!1}}function st(t,e){return et(t,(s,i,r,a)=>{const n=e?.(s,i,r,a);if(n!=null)return n;if(typeof t=="object")switch(Object.prototype.toString.call(t)){case te:case ee:case se:{const c=new t.constructor(t?.valueOf());return m(c,t),c}case ie:{const c={};return m(c,t),c.length=t.length,c[Symbol.iterator]=t[Symbol.iterator],c}default:return}})}function ne(t){return st(t)}function re(t){return t!==null&&typeof t=="object"&&T(t)==="[object Arguments]"}function ae(t){return typeof t=="object"&&t!==null}function it(){}function nt(t){return x(t)}function rt(t){if(typeof t!="object"||t==null)return!1;if(Object.getPrototypeOf(t)===null)return!0;if(Object.prototype.toString.call(t)!=="[object Object]"){const s=t[Symbol.toStringTag];return s==null||!Object.getOwnPropertyDescriptor(t,Symbol.toStringTag)?.writable?!1:t.toString()===`[object ${s}]`}let e=t;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(t)===e}function at(t){if(_(t))return t;if(Array.isArray(t)||x(t)||t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer)return t.slice(0);const e=Object.getPrototypeOf(t),s=e.constructor;if(t instanceof Date||t instanceof Map||t instanceof Set)return new s(t);if(t instanceof RegExp){const i=new s(t);return i.lastIndex=t.lastIndex,i}if(t instanceof DataView)return new s(t.buffer.slice(0));if(t instanceof Error){const i=new s(t.message);return i.stack=t.stack,i.name=t.name,i.cause=t.cause,i}if(typeof File<"u"&&t instanceof File)return new s([t],t.name,{type:t.type,lastModified:t.lastModified});if(typeof t=="object"){const i=Object.create(e);return Object.assign(i,t)}return t}function ct(t,...e){const s=e.slice(0,-1),i=e[e.length-1];let r=t;for(let a=0;a<s.length;a++){const n=s[a];r=$(r,n,i,new Map)}return r}function $(t,e,s,i){if(_(t)&&(t=Object(t)),e==null||typeof e!="object")return t;if(i.has(e))return at(i.get(e));if(i.set(e,t),Array.isArray(e)){e=e.slice();for(let a=0;a<e.length;a++)e[a]=e[a]??void 0}const r=[...Object.keys(e),...Z(e)];for(let a=0;a<r.length;a++){const n=r[a];let c=e[n],o=t[n];if(re(c)&&(c={...c}),re(o)&&(o={...o}),typeof Buffer<"u"&&Buffer.isBuffer(c)&&(c=ne(c)),Array.isArray(c))if(typeof o=="object"&&o!=null){const l=[],p=Reflect.ownKeys(o);for(let f=0;f<p.length;f++){const u=p[f];l[u]=o[u]}o=l}else o=[];const h=s(o,c,n,t,e,i);h!=null?t[n]=h:Array.isArray(c)||ae(o)&&ae(c)?t[n]=$(o,c,s,i):o==null&&rt(c)?t[n]=$({},c,s,i):o==null&&nt(c)?t[n]=ne(c):(o===void 0||c!==void 0)&&(t[n]=c)}return t}function ot(t,...e){return ct(t,...e,it)}const ce="error",pt="wss://relay.walletconnect.org",ht="wc",oe="universal_provider",A=`${ht}@2:${oe}:`,pe="https://rpc.walletconnect.org/v1/",he="generic",lt=`${pe}bundler`,v="call_status",ut=86400,F={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};var dt=Object.defineProperty,ft=Object.defineProperties,mt=Object.getOwnPropertyDescriptors,le=Object.getOwnPropertySymbols,gt=Object.prototype.hasOwnProperty,yt=Object.prototype.propertyIsEnumerable,ue=(t,e,s)=>e in t?dt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,E=(t,e)=>{for(var s in e||(e={}))gt.call(e,s)&&ue(t,s,e[s]);if(le)for(var s of le(e))yt.call(e,s)&&ue(t,s,e[s]);return t},vt=(t,e)=>ft(t,mt(e));function de(t,e,s){var i;const r=I(t);return((i=e.rpcMap)==null?void 0:i[r.reference])||`${pe}?chainId=${r.namespace}:${r.reference}&projectId=${s}`}function wt(t){return t.includes(":")?t.split(":")[1]:t}function fe(t){return t.map(e=>`${e.split(":")[0]}:${e.split(":")[1]}`)}function bt(t,e){const s=Object.keys(e.namespaces).filter(r=>r.includes(t));if(!s.length)return[];const i=[];return s.forEach(r=>{const a=e.namespaces[r].accounts;i.push(...a)}),i}function me(t){return Object.fromEntries(Object.entries(t).filter(([e,s])=>{var i,r;return((i=s?.chains)==null?void 0:i.length)&&((r=s?.chains)==null?void 0:r.length)>0}))}function C(t={},e={}){const s=me(ge(t)),i=me(ge(e));return ot(s,i)}function ge(t){var e,s,i,r,a;const n={};if(!P(t))return n;for(const[c,o]of Object.entries(t)){const h=V(c)?[c]:o.chains,l=o.methods||[],p=o.events||[],f=o.rpcMap||{},u=O(c);n[u]=vt(E(E({},n[u]),o),{chains:D(h,(e=n[u])==null?void 0:e.chains),methods:D(l,(s=n[u])==null?void 0:s.methods),events:D(p,(i=n[u])==null?void 0:i.events)}),(P(f)||P(((r=n[u])==null?void 0:r.rpcMap)||{}))&&(n[u].rpcMap=E(E({},f),(a=n[u])==null?void 0:a.rpcMap))}return n}function ye(t){return t.includes(":")?t.split(":")[2]:t}function ve(t){const e={};for(const[s,i]of Object.entries(t)){const r=i.methods||[],a=i.events||[],n=i.accounts||[],c=V(s)?[s]:i.chains?i.chains:fe(i.accounts);e[s]={chains:c,methods:r,events:a,accounts:n}}return e}function H(t){return typeof t=="number"?t:t.includes("0x")?parseInt(t,16):(t=t.includes(":")?t.split(":")[1]:t,isNaN(Number(t))?t:Number(t))}function Pt(t){try{const e=JSON.parse(t);return typeof e=="object"&&e!==null&&!Array.isArray(e)}catch{return!1}}const we={},w=t=>we[t],U=(t,e)=>{we[t]=e};var Ot=Object.defineProperty,be=Object.getOwnPropertySymbols,It=Object.prototype.hasOwnProperty,St=Object.prototype.propertyIsEnumerable,Pe=(t,e,s)=>e in t?Ot(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,Oe=(t,e)=>{for(var s in e||(e={}))It.call(e,s)&&Pe(t,s,e[s]);if(be)for(var s of be(e))St.call(e,s)&&Pe(t,s,e[s]);return t};const Ie="eip155",$t=["atomic","flow-control","paymasterService","sessionKeys","auxiliaryFunds"],At=t=>t&&t.startsWith("0x")?BigInt(t).toString(10):t,B=t=>t&&t.startsWith("0x")?t:`0x${BigInt(t).toString(16)}`,Se=t=>Object.keys(t).filter(e=>$t.includes(e)).reduce((e,s)=>(e[s]=Et(t[s]),e),{}),Et=t=>typeof t=="string"&&Pt(t)?JSON.parse(t):t,Ct=(t,e,s)=>{const{sessionProperties:i={},scopedProperties:r={}}=t,a={};if(!P(r)&&!P(i))return;const n=Se(i);for(const c of s){const o=At(c);if(!o)continue;a[B(o)]=n;const h=r?.[`${Ie}:${o}`];if(h){const l=h?.[`${Ie}:${o}:${e}`];a[B(o)]=Oe(Oe({},a[B(o)]),Se(l||h))}}for(const[c,o]of Object.entries(a))Object.keys(o).length===0&&delete a[c];return Object.keys(a).length>0?a:void 0};var jt=Object.defineProperty,Nt=(t,e,s)=>e in t?jt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,qt=(t,e,s)=>Nt(t,typeof e!="symbol"?e+"":e,s);let L;class J{constructor(e){qt(this,"storage"),this.storage=e}async getItem(e){return await this.storage.getItem(e)}async setItem(e,s){return await this.storage.setItem(e,s)}async removeItem(e){return await this.storage.removeItem(e)}static getStorage(e){return L||(L=new J(e)),L}}var Dt=Object.defineProperty,Rt=Object.defineProperties,_t=Object.getOwnPropertyDescriptors,$e=Object.getOwnPropertySymbols,xt=Object.prototype.hasOwnProperty,Ft=Object.prototype.propertyIsEnumerable,Ae=(t,e,s)=>e in t?Dt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,Ht=(t,e)=>{for(var s in e||(e={}))xt.call(e,s)&&Ae(t,s,e[s]);if($e)for(var s of $e(e))Ft.call(e,s)&&Ae(t,s,e[s]);return t},Ut=(t,e)=>Rt(t,_t(e));async function Bt(t,e){const s=I(t.result.capabilities.caip345.caip2),i=t.result.capabilities.caip345.transactionHashes,r=await Promise.allSettled(i.map(p=>Lt(s.reference,p,e))),a=r.filter(p=>p.status==="fulfilled").map(p=>p.value).filter(p=>p);r.filter(p=>p.status==="rejected").forEach(p=>console.warn("Failed to fetch transaction receipt:",p.reason));const n=!a.length||a.some(p=>!p),c=a.every(p=>p?.status==="0x1"),o=a.every(p=>p?.status==="0x0"),h=a.some(p=>p?.status==="0x0");let l;return n?l=100:c?l=200:o?l=500:h&&(l=600),{id:t.result.id,version:t.request.version,atomic:t.request.atomicRequired,chainId:t.request.chainId,capabilities:t.result.capabilities,receipts:a,status:l}}async function Lt(t,e,s){return await s(parseInt(t)).request(k("eth_getTransactionReceipt",[e]))}async function Mt({sendCalls:t,storage:e}){const s=await e.getItem(v);await e.setItem(v,Ut(Ht({},s),{[t.result.id]:{request:t.request,result:t.result,expiry:Ne(ut)}}))}async function zt({resultId:t,storage:e}){const s=await e.getItem(v);if(s){delete s[t],await e.setItem(v,s);for(const i in s)Y(s[i].expiry)&&delete s[i];await e.setItem(v,s)}}async function Gt({resultId:t,storage:e}){const s=await e.getItem(v),i=s?.[t];if(i&&!Y(i.expiry))return i;await zt({resultId:t,storage:e})}var Wt=Object.defineProperty,Jt=Object.defineProperties,Kt=Object.getOwnPropertyDescriptors,Ee=Object.getOwnPropertySymbols,Vt=Object.prototype.hasOwnProperty,Yt=Object.prototype.propertyIsEnumerable,M=(t,e,s)=>e in t?Wt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,z=(t,e)=>{for(var s in e||(e={}))Vt.call(e,s)&&M(t,s,e[s]);if(Ee)for(var s of Ee(e))Yt.call(e,s)&&M(t,s,e[s]);return t},G=(t,e)=>Jt(t,Kt(e)),g=(t,e,s)=>M(t,typeof e!="symbol"?e+"":e,s);class Xt{constructor(e){g(this,"name","eip155"),g(this,"client"),g(this,"chainId"),g(this,"namespace"),g(this,"httpProviders"),g(this,"events"),g(this,"storage"),this.namespace=e.namespace,this.events=w("events"),this.client=w("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain()),this.storage=J.getStorage(this.client.core.storage)}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e);case"wallet_sendCalls":return await this.sendCalls(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,s){this.httpProviders[e]||this.setHttpProvider(parseInt(e),s);const i=this.chainId;this.chainId=parseInt(e),this.events.emit(F.DEFAULT_CHAIN_CHANGED,{currentCaipChainId:`${this.name}:${e}`,previousCaipChainId:`${this.name}:${i}`})}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,s){const i=s||de(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Q(new _e(i,w("disableProviderPing")))}setHttpProvider(e,s){const i=this.createHttpProvider(e,s);i&&(this.httpProviders[e]=i)}createHttpProviders(){const e={};return this.namespace.chains.forEach(s=>{var i;const r=parseInt(wt(s));e[r]=this.createHttpProvider(r,(i=this.namespace.rpcMap)==null?void 0:i[s])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(s=>s.split(":")[1]===this.chainId.toString()).map(s=>s.split(":")[2]))]:[]}getHttpProvider(e){const s=e||this.chainId;return this.httpProviders[s]||(this.httpProviders=G(z({},this.httpProviders),{[s]:this.createHttpProvider(s)}),this.httpProviders[s])}async handleSwitchChain(e){var s,i;let r=e.request.params?(s=e.request.params[0])==null?void 0:s.chainId:"0x0";r=r.startsWith("0x")?r:`0x${r}`;const a=parseInt(r,16);if(this.isChainApproved(a))this.setDefaultChain(`${a}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:r}]},chainId:(i=this.namespace.chains)==null?void 0:i[0]}),this.setDefaultChain(`${a}`);else throw new Error(`Failed to switch to chain 'eip155:${a}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var s,i,r,a,n;const c=(i=(s=e.request)==null?void 0:s.params)==null?void 0:i[0],o=((a=(r=e.request)==null?void 0:r.params)==null?void 0:a[1])||[];if(!c)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const h=this.client.session.get(e.topic),l=((n=h?.sessionProperties)==null?void 0:n.capabilities)||{},p=`${c}${o.join(",")}`,f=l?.[p];if(f)return f;let u;try{u=Ct(h,c,o)}catch(q){console.warn("Failed to extract capabilities from session",q)}if(u)return u;const K=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:G(z({},h.sessionProperties||{}),{capabilities:G(z({},l||{}),{[p]:K})})})}catch(q){console.warn("Failed to update session with capabilities",q)}return K}async getCallStatus(e){var s,i,r;const a=this.client.session.get(e.topic),n=(s=a.sessionProperties)==null?void 0:s.bundler_name;if(n){const h=this.getBundlerUrl(e.chainId,n);try{return await this.getUserOperationReceipt(h,e)}catch(l){console.warn("Failed to fetch call status from bundler",l,h)}}const c=(i=a.sessionProperties)==null?void 0:i.bundler_url;if(c)try{return await this.getUserOperationReceipt(c,e)}catch(h){console.warn("Failed to fetch call status from custom bundler",h,c)}const o=await Gt({resultId:(r=e.request.params)==null?void 0:r[0],storage:this.storage});if(o)try{return await Bt(o,this.getHttpProvider.bind(this))}catch(h){console.warn("Failed to fetch call status from stored send calls",h,o)}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,s){var i;const r=new URL(e),a=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(k("eth_getUserOperationReceipt",[(i=s.request.params)==null?void 0:i[0]]))});if(!a.ok)throw new Error(`Failed to fetch user operation receipt - ${a.status}`);return await a.json()}getBundlerUrl(e,s){return`${lt}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${s}`}async sendCalls(e){var s,i,r;const a=await this.client.request(e),n=(s=e.request.params)==null?void 0:s[0],c=a?.id,o=a?.capabilities||{},h=(i=o?.caip345)==null?void 0:i.caip2,l=(r=o?.caip345)==null?void 0:r.transactionHashes;return!c||!h||!(l!=null&&l.length)||await Mt({sendCalls:{request:n,result:a},storage:this.storage}),a}}var kt=Object.defineProperty,Qt=(t,e,s)=>e in t?kt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,b=(t,e,s)=>Qt(t,typeof e!="symbol"?e+"":e,s);class Zt{constructor(e){b(this,"name",he),b(this,"client"),b(this,"httpProviders"),b(this,"events"),b(this,"namespace"),b(this,"chainId"),this.namespace=e.namespace,this.events=w("events"),this.client=w("client"),this.chainId=this.getDefaultChain(),this.name=this.getNamespaceName(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,s){this.httpProviders[e]||this.setHttpProvider(e,s);const i=this.chainId;this.chainId=e,this.events.emit(F.DEFAULT_CHAIN_CHANGED,{currentCaipChainId:`${this.name}:${e}`,previousCaipChainId:`${this.name}:${i}`})}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getNamespaceName(){const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return I(e).namespace}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(s=>s.split(":")[1]===this.chainId.toString()).map(s=>s.split(":")[2]))]:[]}createHttpProviders(){var e,s;const i={};return(s=(e=this.namespace)==null?void 0:e.accounts)==null||s.forEach(r=>{var a,n;const c=I(r),o=(n=(a=this.namespace)==null?void 0:a.rpcMap)==null?void 0:n[`${c.namespace}:${c.reference}`];i[c.reference]=this.createHttpProvider(r,o)}),i}getHttpProvider(e){const s=I(e).reference,i=this.httpProviders[s];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return i}setHttpProvider(e,s){const i=this.createHttpProvider(e,s);i&&(this.httpProviders[e]=i)}createHttpProvider(e,s){const i=s||de(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Q(new Re(i,w("disableProviderPing")))}}var Tt=Object.defineProperty,es=Object.defineProperties,ts=Object.getOwnPropertyDescriptors,Ce=Object.getOwnPropertySymbols,ss=Object.prototype.hasOwnProperty,is=Object.prototype.propertyIsEnumerable,W=(t,e,s)=>e in t?Tt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,S=(t,e)=>{for(var s in e||(e={}))ss.call(e,s)&&W(t,s,e[s]);if(Ce)for(var s of Ce(e))is.call(e,s)&&W(t,s,e[s]);return t},j=(t,e)=>es(t,ts(e)),d=(t,e,s)=>W(t,typeof e!="symbol"?e+"":e,s);class N{constructor(e){d(this,"client"),d(this,"namespaces"),d(this,"optionalNamespaces"),d(this,"sessionProperties"),d(this,"scopedProperties"),d(this,"events",new xe),d(this,"rpcProviders",{}),d(this,"session"),d(this,"providerOpts"),d(this,"logger"),d(this,"uri"),d(this,"disableProviderPing",!1);var s,i;this.providerOpts=e,this.logger=qe({logger:(s=e.logger)!=null?s:ce,name:(i=this.providerOpts.name)!=null?i:oe}),this.disableProviderPing=e?.disableProviderPing||!1}static async init(e){const s=new N(e);return await s.initialize(),s}async request(e,s,i){const[r,a]=this.validateChain(s);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(r).request({request:S({},e),chainId:`${r}:${a}`,topic:this.session.topic,expiry:i})}sendAsync(e,s,i,r){const a=new Date().getTime();this.request(e,i,r).then(n=>s(null,De(a,n))).catch(n=>s(n,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:X("USER_DISCONNECTED")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(e),this.cleanupPendingPairings(),!e.skipPairing)return await this.pair(e.pairingTopic)}async authenticate(e,s){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(e),await this.cleanupPendingPairings();const{uri:i,response:r}=await this.client.authenticate(e,s);i&&(this.uri=i,this.events.emit("display_uri",i));const a=await r();if(this.session=a.session,this.session){const n=ve(this.session.namespaces);this.namespaces=C(this.namespaces,n),await this.persist("namespaces",this.namespaces),this.onConnect()}return a}on(e,s){this.events.on(e,s)}once(e,s){this.events.once(e,s)}removeListener(e,s){this.events.removeListener(e,s)}off(e,s){this.events.off(e,s)}get isWalletConnect(){return!0}async pair(e){const{uri:s,approval:i}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});s&&(this.uri=s,this.events.emit("display_uri",s));const r=await i();this.session=r;const a=ve(r.namespaces);return this.namespaces=C(this.namespaces,a),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(e,s){try{if(!this.session)return;const[i,r]=this.validateChain(e);this.getProvider(i).setDefaultChain(r,s)}catch(i){if(!/Please call connect/.test(i.message))throw i}}async cleanupPendingPairings(e={}){try{this.logger.info("Cleaning up inactive pairings...");const s=this.client.pairing.getAll();if(!R(s))return;for(const i of s)e.deletePairings?this.client.core.expirer.set(i.topic,0):await this.client.core.relayer.subscriber.unsubscribe(i.topic);this.logger.info(`Inactive pairings cleared: ${s.length}`)}catch(s){this.logger.warn(s,"Failed to cleanup pending pairings")}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var e,s;if(this.client=this.providerOpts.client||await je.init({core:this.providerOpts.core,logger:this.providerOpts.logger||ce,relayUrl:this.providerOpts.relayUrl||pt,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(i){throw this.logger.error(i,"Failed to get session"),new Error(`The provided session: ${(s=(e=this.providerOpts)==null?void 0:e.session)==null?void 0:s.topic} doesn't exist in the Sign client`)}else{const i=this.client.session.getAll();this.session=i[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const e=[...new Set(Object.keys(this.session.namespaces).map(s=>O(s)))];U("client",this.client),U("events",this.events),U("disableProviderPing",this.disableProviderPing),e.forEach(s=>{if(!this.session)return;const i=bt(s,this.session);if(i?.length===0)return;const r=fe(i),a=C(this.namespaces,this.optionalNamespaces),n=j(S({},a[s]),{accounts:i,chains:r});switch(s){case"eip155":this.rpcProviders[s]=new Xt({namespace:n});break;default:this.rpcProviders[s]=new Zt({namespace:n})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{var s;const{topic:i}=e;i===((s=this.session)==null?void 0:s.topic)&&this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{var s;const{params:i,topic:r}=e;if(r!==((s=this.session)==null?void 0:s.topic))return;const{event:a}=i;if(a.name==="accountsChanged"){const n=a.data;n&&R(n)&&this.events.emit("accountsChanged",n.map(ye))}else if(a.name==="chainChanged"){const n=i.chainId,c=i.event.data,o=O(n),h=H(n)!==H(c)?`${o}:${H(c)}`:n;this.onChainChanged({currentCaipChainId:h})}else this.events.emit(a.name,a.data);this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:s})=>{var i,r;if(e!==((i=this.session)==null?void 0:i.topic))return;const{namespaces:a}=s,n=(r=this.client)==null?void 0:r.session.get(e);this.session=j(S({},n),{namespaces:a}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:s})}),this.client.on("session_delete",async e=>{var s;e.topic===((s=this.session)==null?void 0:s.topic)&&(await this.cleanup(),this.events.emit("session_delete",e),this.events.emit("disconnect",j(S({},X("USER_DISCONNECTED")),{data:e.topic})))}),this.on(F.DEFAULT_CHAIN_CHANGED,e=>{this.onChainChanged(j(S({},e),{internal:!0}))})}getProvider(e){return this.rpcProviders[e]||this.rpcProviders[he]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var s;this.getProvider(e).updateNamespace((s=this.session)==null?void 0:s.namespaces[e])})}setNamespaces(e){const{namespaces:s={},optionalNamespaces:i={},sessionProperties:r,scopedProperties:a}=e;this.optionalNamespaces=C(s,i),this.sessionProperties=r,this.scopedProperties=a}validateChain(e){const[s,i]=e?.split(":")||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[s,i];if(s&&!Object.keys(this.namespaces||{}).map(n=>O(n)).includes(s))throw new Error(`Namespace '${s}' is not configured. Please call connect() first with namespace config.`);if(s&&i)return[s,i];const r=O(Object.keys(this.namespaces)[0]),a=this.rpcProviders[r].getDefaultChain();return[r,a]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}async onChainChanged({currentCaipChainId:e,previousCaipChainId:s,internal:i=!1}){if(!this.namespaces)return;const[r,a]=this.validateChain(e);a&&(this.updateNamespaceChain(r,a),i?(this.events.emit("chainChanged",a),this.emitAccountsChangedOnChainChange({namespace:r,currentCaipChainId:e,previousCaipChainId:s})):this.getProvider(r).setDefaultChain(a),await this.persist("namespaces",this.namespaces))}emitAccountsChangedOnChainChange({namespace:e,currentCaipChainId:s,previousCaipChainId:i}){var r,a;try{if(i===s)return;const n=(a=(r=this.session)==null?void 0:r.namespaces[e])==null?void 0:a.accounts;if(!n)return;const c=n.filter(o=>o.includes(`${s}:`)).map(ye);if(!R(c))return;this.events.emit("accountsChanged",c)}catch(n){this.logger.warn(n,"Failed to emit accountsChanged on chain change")}}updateNamespaceChain(e,s){if(!this.namespaces)return;const i=this.namespaces[e]?e:`${e}:${s}`,r={chains:[],methods:[],events:[],defaultChain:s};this.namespaces[i]?this.namespaces[i]&&(this.namespaces[i].defaultChain=s):this.namespaces[i]=r}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(e,s){var i;const r=((i=this.session)==null?void 0:i.topic)||"";await this.client.core.storage.setItem(`${A}/${e}${r}`,s)}async getFromStore(e){var s;const i=((s=this.session)==null?void 0:s.topic)||"";return await this.client.core.storage.getItem(`${A}/${e}${i}`)}async deleteFromStore(e){var s;const i=((s=this.session)==null?void 0:s.topic)||"";await this.client.core.storage.removeItem(`${A}/${e}${i}`)}async cleanupStorage(){var e;try{if(((e=this.client)==null?void 0:e.session.length)>0)return;const s=await this.client.core.storage.getKeys();for(const i of s)i.startsWith(A)&&await this.client.core.storage.removeItem(i)}catch(s){this.logger.warn(s,"Failed to cleanup storage")}}}const ns=N;export{ns as UniversalProvider,N as default};
//# sourceMappingURL=index.js.map
