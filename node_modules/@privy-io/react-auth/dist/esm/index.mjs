import{g as e,a as t,s as r,b as s,T as n,u as o,c as i,d as l,C as d,e as h,f as w,h as p,p as y,U as m,i as f,j as A,t as k,k as C,M as v,l as E,A as T,m as S,n as U,L as I,o as W,I as R,q as P,S as M,B as N,P as O,E as F,r as L,v as H,w as x,x as D,y as K,G as q,W as z,z as j,D as B,F as G,H as Q,J,K as ee,N as te,O as re,Q as se,R as ne}from"./privy-provider-BG8GtKO6.mjs";export{Y as Captcha,Z as ConnectorManager,$ as EthereumWalletConnector,ad as LoginModal,a6 as PrivyClient,V as PrivyProvider,a5 as VERSION,_ as WalletConnector,a3 as errorIndicatesMaxMfaRetries,a4 as errorIndicatesMfaTimeout,a2 as errorIndicatesMfaVerificationFailed,X as getAccessToken,aa as useCreateWallet,a7 as useIdentityToken,ac as useImportWallet,a8 as useLogout,a0 as useMfa,a1 as useMfaEnrollment,ae as useMigrateWallets,a9 as useRegisterMfaListener,ab as useSolanaWallets}from"./privy-provider-BG8GtKO6.mjs";import{useCallback as oe,useMemo as ie,useEffect as le,useContext as ce,useState as ue,useRef as de}from"react";import{P as he,a as we}from"./paths-DCwuPDUk.mjs";import{u as pe,I as ye}from"./internal-context-qdNgTV5f.mjs";import{u as me,P as ge,g as fe,a as Ae,b as ke,c as Ce}from"./use-sign-with-user-signer-CpL9I6iB.mjs";export{c as useActiveWallet,a as useConnectWallet,b as useFundWallet,u as useLogin}from"./useActiveWallet-BGo6de6R.mjs";import{F as ve}from"./frame-DMd4vZ0H.mjs";import{MfaAuthTotpVerify as Ee,MfaAuthPasskeyInit as Te,MfaAuthPasskeyVerify as Se,MfaAuthTotpInit as Ue,MfaAuthTotpEnroll as Ie,MfaAuthTotpUnenroll as We,MfaAuthPasskeyEnrollment as Re}from"@privy-io/public-api";import{jsxs as be,Fragment as Pe,jsx as Me}from"react/jsx-runtime";import Ne from"@heroicons/react/24/outline/QuestionMarkCircleIcon";import _e from"@heroicons/react/24/outline/ShieldCheckIcon";import{zeroAddress as Oe,getAddress as Fe,createWalletClient as Le,http as He,parseSignature as xe}from"viem";import{hashAuthorization as De}from"viem/utils";import{getWallet as Ke,updateWallet as qe,generateAuthorizationSignature as ze,PrivyClientError as je}from"@privy-io/js-sdk-core";export{DEFAULT_SUPPORTED_CHAINS as SUPPORTED_CHAINS,addPrivyRpcToChain,addRpcUrlOverrideToChain}from"@privy-io/js-sdk-core";export{g as getEmbeddedConnectedWallet}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import{toAccount as Ve}from"viem/accounts";import"mipd";import"react-device-detect";import"uuid";import"jose";import"eventemitter3";import"@coinbase/wallet-sdk";import"@privy-io/ethereum";import"@marsidev/react-turnstile";import"styled-components";import"tinycolor2";import"@heroicons/react/24/outline/DevicePhoneMobileIcon";import"@heroicons/react/24/outline/FingerPrintIcon";import"@heroicons/react/24/outline/PhoneIcon";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/XMarkIcon";import"@heroicons/react/24/outline/CalendarIcon";import"@heroicons/react/24/outline/ExclamationTriangleIcon";import"@heroicons/react/24/outline/ChevronDownIcon";import"zustand";import"@headlessui/react";import"lucide-react";import"@walletconnect/ethereum-provider";import"fast-password-entropy";import"secure-password-utilities";import"secure-password-utilities/wordlists";import"@heroicons/react/24/outline/UserCircleIcon";import"@heroicons/react/20/solid/CheckIcon";import"@heroicons/react/24/outline/EnvelopeIcon";import"@heroicons/react/24/outline/WalletIcon";import"@heroicons/react/24/outline/ExclamationCircleIcon";import"@heroicons/react/24/outline/Square2StackIcon";import"@heroicons/react/24/outline";import"@tanstack/react-virtual";import"@heroicons/react/24/outline/CheckIcon";import"qrcode";import"@heroicons/react/24/outline/LockClosedIcon";import"@heroicons/react/24/outline/PencilSquareIcon";import"@heroicons/react/24/outline/ArrowPathIcon";import"@heroicons/react/24/outline/EyeIcon";import"@heroicons/react/24/outline/EyeSlashIcon";import"@heroicons/react/24/outline/KeyIcon";import"@heroicons/react/24/solid/CheckCircleIcon";import"@heroicons/react/24/outline/ArrowDownTrayIcon";import"@heroicons/react/24/outline/ClipboardDocumentCheckIcon";import"@heroicons/react/24/outline/DocumentDuplicateIcon";import"@heroicons/react/24/solid/XCircleIcon";import"@heroicons/react/24/outline/CheckCircleIcon";import"@heroicons/react/24/outline/InformationCircleIcon";import"@heroicons/react/24/outline/CreditCardIcon";import"@heroicons/react/24/outline/QrCodeIcon";import"@heroicons/react/24/solid/ArrowsRightLeftIcon";import"@heroicons/react/24/outline/GlobeAltIcon";import"ofetch";import"@heroicons/react/24/outline/ClipboardDocumentIcon";import"@heroicons/react/24/solid/CheckBadgeIcon";import"@heroicons/react/24/solid/IdentificationIcon";import"@heroicons/react/24/outline/ChevronRightIcon";import"@heroicons/react/24/outline/MinusCircleIcon";import"@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon";import"@heroicons/react/24/outline/ClockIcon";import"@heroicons/react/24/solid/ShieldCheckIcon";import"js-cookie";const Be=()=>{let{user:r}=me(),{walletProxy:a}=pe();return{recover:oe((async s=>{if(!a)throw Error("Wallet proxy is not ready");let n=await e();if(!r||!n)throw new he("User must be logged in before attempting to modify the recovery method.");let{entropyId:o,entropyIdVerifier:i}=t(r);try{await a.recover({entropyId:o,entropyIdVerifier:i,accessToken:n,...s})}catch{throw new he("Unable to recover wallets")}}),[a,r])}},Ge=()=>{let{client:e,setAuthenticated:t,setUser:r}=pe();return ie((()=>({init:async()=>{if(!e)throw new he("Must initialize Privy client first.");let t=new ve;return e.startAuthFlow(t),await t.init()},login:async({fid:a,message:s,signature:n})=>{if(!e)throw new he("Must initialize Privy client first.");if(!(e.authFlow instanceof ve))throw new he("Must initialize Farcaster Mini App flow first.");e.authFlow.setAuthData({message:s,signature:n,fid:a});let{user:o}=await e.authenticate();if(!o)throw new he("Failed to login with Farcaster V2");return r(o),t(!0),{user:o}}})),[e,r,t])},$e=()=>ie((()=>({getAccessTokenForProvider:({appId:e})=>{try{let t=r.get(s(e));if("string"!=typeof t)return{token:null};{let a=new n(t);return a.isExpired()?(r.del(s(e)),{token:null}):{token:a.value}}}catch(e){return console.error(e),{token:null}}}})),[]),Qe=e=>{o("login",e);let t=i(),r=l(),{ready:a,user:s}=me(),{initLoginWithHeadlessOAuth:n,loginWithHeadlessOAuth:c,oAuthState:u,setOAuthState:p,isHeadlessOAuthLoading:y}=pe(),m=oe((async e=>{try{if(t.enabled&&"success"!==t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);return await n(e.provider,t.token,e.disableSignup)}catch(e){throw p({status:"error",error:e}),e}}),[n,t]),g=oe((async()=>{let e=h();try{if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(s&&s[e.provider])return console.warn("User is already logged in with this OAuth provider"),s;if(e.popupFlow)return}catch(e){throw p({status:"error",error:e}),e}try{return await c(e)}catch(e){throw p({status:"error",error:e}),e}finally{w()}}),[c]);return le((()=>{let e=h();a&&r&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&g().catch((()=>{}))}),[a,r]),{initOAuth:m,loading:y,state:u}},Xe=e=>{let t=i(),{emailOtpState:r,setEmailOtpState:a,initLoginWithEmail:s,loginWithCode:n}=pe();return{sendCode:oe((async({email:r,disableSignup:n})=>{try{let e;if(!r)throw Error("Email required to send OTP code");if(t.enabled&&"error"===t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await s({email:r,captchaToken:e,disableSignup:n,withPrivyUi:!1})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||we.UNKNOWN_AUTH_ERROR),r}}),[s]),loginWithCode:oe((async({code:r})=>{try{if(t.enabled&&"error"===t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);let{user:a,isNewUser:s,wasAlreadyAuthenticated:o,linkedAccount:i}=await n(r);e?.onComplete?.({user:a,isNewUser:s,wasAlreadyAuthenticated:o,loginMethod:"email",loginAccount:i})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||we.UNKNOWN_AUTH_ERROR),r}}),[n,t.status]),state:r}},Je=e=>{let t=i(),{initSignupWithPasskey:r,signupWithPasskey:a,passkeyAuthState:s,setPasskeyAuthState:n}=pe();return{signupWithPasskey:oe((async()=>{try{let s;if(t.enabled&&"error"===t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),s=await t.waitForResult()),await r({captchaToken:s,withPrivyUi:!1});let{user:n,isNewUser:o,wasAlreadyAuthenticated:i,loginAccount:l}=await a();e?.onComplete?.({user:n,isNewUser:o,wasAlreadyAuthenticated:i,loginMethod:"passkey",loginAccount:l})}catch(t){throw n({status:"error",error:t}),e?.onError?.(t.privyErrorCode||we.UNKNOWN_AUTH_ERROR),t}}),[a,t.status]),state:s}},Ye=e=>{let t=i(),{initLoginWithPasskey:r,loginWithPasskey:a,passkeyAuthState:s,setPasskeyAuthState:n}=pe();return{loginWithPasskey:oe((async s=>{try{let n;if(t.enabled&&"error"===t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),n=await t.waitForResult()),await r({captchaToken:n,withPrivyUi:!1});let{user:o,isNewUser:i,wasAlreadyAuthenticated:l,loginAccount:c}=await a(s);e?.onComplete?.({user:o,isNewUser:i,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(s){throw n({status:"error",error:s}),e?.onError?.(s.privyErrorCode||we.UNKNOWN_AUTH_ERROR),s}}),[a,t.status]),state:s}},Ze=e=>{let{initLinkWithPasskey:t,linkWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:s}=pe();return{linkWithPasskey:oe((async()=>{try{await t();let a=await r();if(!a)throw Error("Error, user not found");let s=a.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:a,linkMethod:"passkey",linkedAccount:s})}catch(t){throw s({status:"error",error:t}),e?.onError?.(t.privyErrorCode||we.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[r]),state:a}},et=e=>{let t=i(),{smsOtpState:r,setSmsOtpState:a,initLoginWithSms:s,loginWithCode:n}=pe();return{sendCode:oe((async({phoneNumber:r,disableSignup:n})=>{try{let e;if(!r)throw Error("SMS required to send OTP code");if(t.enabled&&"error"===t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await s({phoneNumber:r,captchaToken:e,disableSignup:n,withPrivyUi:!1})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||we.UNKNOWN_AUTH_ERROR),r}}),[s]),loginWithCode:oe((async({code:r})=>{try{if(t.enabled&&"error"===t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);let{user:a,isNewUser:s,wasAlreadyAuthenticated:o,linkedAccount:i}=await n(r);e?.onComplete?.({user:a,isNewUser:s,wasAlreadyAuthenticated:o,loginMethod:"sms",loginAccount:i})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||we.UNKNOWN_AUTH_ERROR),r}}),[n,t.status]),state:r}},tt=e=>{let{connectOrCreateWallet:t}=me();return o("connectOrCreateWallet",e),{connectOrCreateWallet:t}},rt=e=>{let t=i(),{siweState:r,setSiweState:a,linkWithSiwe:s,generateSiweMessage:n}=pe();return{generateSiweMessage:oe((async({address:t,chainId:r})=>{try{if(!t||!r)throw Error("wallet address and chainId required to generate nonce");return await n({address:t,chainId:r}).then((e=>e))}catch(t){throw a({status:"error",error:t}),e?.onError?.(t.privyErrorCode||we.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[n]),linkWithSiwe:oe((async({signature:r,message:n,chainId:o,walletClientType:i,connectorType:l})=>{try{if(t.enabled&&"success"!==t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);let{user:a,linkedAccount:c}=await s({message:n,signature:r,chainId:o,walletClientType:i,connectorType:l});c&&e?.onSuccess?.({user:a,linkMethod:"siwe",linkedAccount:c})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||we.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[s,t.status]),state:r}},at=e=>{let t=i(),{siweState:r,setSiweState:a,client:s,generateSiweMessage:n,loginWithSiwe:o}=pe();return{generateSiweNonce:oe((async r=>{try{let e;if(t.enabled&&"error"===t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),a({status:"generating-message"});let n=await s.generateSiweNonce({address:r?.address,captchaToken:e});return a({status:"awaiting-signature"}),n}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||we.UNKNOWN_AUTH_ERROR),r}}),[s,t]),generateSiweMessage:oe((async({address:r,chainId:s})=>{try{let e;if(t.enabled&&"error"===t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await n({address:r,chainId:s,captchaToken:e})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||we.UNKNOWN_AUTH_ERROR),r}}),[n,t]),loginWithSiwe:oe((async({message:r,signature:s,disableSignup:n})=>{try{let a;if(t.enabled&&"error"===t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),a=await t.waitForResult());let i=await o({message:r,signature:s,captchaToken:a,disableSignup:n});return e?.onComplete?.({user:i,isNewUser:!1,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),i}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||we.UNKNOWN_AUTH_ERROR),r}}),[o,t.status]),state:r}},st=()=>{let e=i(),{client:t,setAuthenticated:r,setUser:a,setIsNewUser:s}=pe(),{authenticated:n}=p();return{generateSiwsMessage:oe((async({address:r})=>{let a;if(e.enabled&&"error"===e.status)throw new d(e.error,null,we.CAPTCHA_FAILURE);e.enabled&&"success"!==e.status&&(e.execute(),a=await e.waitForResult());let s=await t.generateSiwsNonce({address:r,captchaToken:a});return y({address:r,nonce:s})}),[e,t]),loginWithSiws:oe((async({message:o,signature:i,disableSignup:l})=>{if(n)throw Error("User already authenticated");if(e.enabled&&"error"===e.status)throw new d(e.error,null,we.CAPTCHA_FAILURE);e.enabled&&"success"!==e.status&&(e.execute(),await e.waitForResult());let{user:c,isNewUser:u}=await t.authenticateWithSiws({message:o,signature:i,mode:l?"no-signup":"login-or-sign-up",messageType:"plain"});if(!c)throw Error("Authentication failed - no user returned");return a(c),s(u||!1),r(!0),c}),[n,e,t,r,a,s])}},nt=()=>{let e=i(),{client:t,setUser:r,refreshSessionAndUser:a}=pe(),{authenticated:s}=p();return{generateSiwsMessage:oe((async({address:r})=>{let a;if(e.enabled&&"error"===e.status)throw new d(e.error,null,we.CAPTCHA_FAILURE);e.enabled&&"success"!==e.status&&(e.execute(),a=await e.waitForResult());let s=await t.generateSiwsNonce({address:r,captchaToken:a});return y({address:r,nonce:s})}),[e,t]),linkWithSiws:oe((async({signature:n,message:o,walletClientType:i,connectorType:l})=>{if(!s)throw Error("User must be authenticated before linking");if(e.enabled&&"error"===e.status)throw new d(e.error,null,we.CAPTCHA_FAILURE);let c=await t.linkWithSiws({message:o,signature:n,walletClientType:i,connectorType:l,messageType:"plain"}),u=(e=>{if(!e)return;let t=e.linkedAccounts;return t&&0!==t.length?t[t.length-1]:void 0})(c=await a()??c)||null;return r(c||null),{user:c,linkedAccount:u}}),[s,e,t,a,r])}};function ot(){let{signTransaction:e}=ce(ge);return{signTransaction:e}}function it(e){let{linkEmail:t,linkPhone:r,linkWallet:a,linkGoogle:s,linkApple:n,linkTwitter:i,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkLine:h,linkSpotify:w,linkInstagram:p,linkTelegram:y,linkFarcaster:m,linkPasskey:g}=ce(ge);return o("linkAccount",e),{linkEmail:t,linkPhone:r,linkWallet:a,linkGoogle:s,linkApple:n,linkTwitter:i,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkLine:h,linkSpotify:w,linkInstagram:p,linkFarcaster:m,linkTelegram:y,linkPasskey:g}}function lt(e){let{updateEmail:t,updatePhone:r}=ce(ge);return o("update",e),{updateEmail:t,updatePhone:r}}const ct=e=>{let{user:t}=me(),{loginWithCode:r,emailOtpState:a,setEmailOtpState:s,client:n,inProgressAuthFlowRef:o,inProgressLoginOrLinkMethodRef:i}=pe();return{state:a,sendCode:oe((async({newEmailAddress:r})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");let e=new m(t.email.address,r);n.startAuthFlow(e),await e.sendCodeEmail({withPrivyUi:!1})}catch(r){s({status:"error",error:r}),e?.onError?.(r.privyErrorCode||we.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email]),verifyCode:oe((async({code:a})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");o.current="update",i.current="email";let{user:s,linkedAccount:n}=await r(a);return e?.onSuccess?.({user:s,updateMethod:"email",updatedAccount:n}),{user:s}}catch(a){s({status:"error",error:a}),e?.onError?.(a.privyErrorCode||we.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email])}},ut=()=>{let{connectCoinbaseSmartWallet:e}=pe();return{connectCoinbaseSmartWallet:e}},dt=()=>{let{connectBaseAccount:e}=pe();return{connectBaseAccount:e}},ht=()=>{let{baseAccountSdk:e}=pe();return{baseAccountSdk:e}},wt=()=>{let{setModalData:e}=f(),{openModal:t,privy:r,closePrivyModal:a}=pe(),{user:s}=me();return ie((()=>({verify:async({standalone:n=!0}={standalone:!0})=>new Promise(((o,i)=>s?0===s.mfaMethods.length?o():(e((e=>({...e,mfaVerify:{onSuccess:async()=>{n?await a({shouldCallAuthOnSuccess:!1,isSuccess:!0}):A.setState({inProgressMfaFlow:void 0}),o()},onFailure:async e=>{n?await a({shouldCallAuthOnSuccess:!1,isSuccess:!1}):A.setState({inProgressMfaFlow:void 0}),i(e)},sendSmsCode:async()=>{throw Error("Not enabled")},verifySmsCode:async()=>{throw Error("Not enabled")},verifyTotpCode:async e=>{await r.fetchPrivyRoute(Ee,{body:{code:e}})},generateOptions:async()=>k((await r.fetchPrivyRoute(Te,{body:{}})).options),verifyPasskey:async e=>{let t=await import("@simplewebauthn/browser"),a=await t.startAuthentication(e);await r.fetchPrivyRoute(Se,{body:{authenticator_response:C(a)}})}}}))),void(n?t(v):A.setState({inProgressMfaFlow:"auth"}))):i(Error("Must be logged in to verify MFA"))))})),[r,e,t,a])},pt={component:()=>{let{user:e,ready:t}=me(),{app:r,data:a,onUserCloseViaDialogOrKeybindRef:s}=f(),[n,o]=ue(null),[i,l]=ue(null),[c,u]=ue(null),[d,h]=ue(!1),[w,p]=ue(!1),[y,m]=ue(),g=async()=>{y?A(y):e?await k({user:e}):A(Error("Must be logged in to manage MFA")),setTimeout((()=>{o(null),l(null)}),500)};if(s.current=g,!a?.mfaEnroll)throw Error("Missing modal data for MFA enrollment screen.");let{onFailure:A,onSuccess:k,mfaMethods:C,verify:v,generateTotpSecret:b,enrollTotp:_,unenrollTotp:x,enrollPasskey:D}=a.mfaEnroll,K=e?.mfaMethods.includes("sms"),q=e?.mfaMethods.includes("totp"),z=e?.mfaMethods.includes("passkey"),j=!!e?.phone,V=e?.linkedAccounts.filter((e=>"passkey"===e.type)).map((e=>e.credentialId))??[];function B(){o(null),l(null),m(void 0)}async function G(e=V){try{m(void 0),p(!0);let t=await D(e);return await k({user:t})}catch(e){m(e)}finally{p(!1),h(!1)}}if(!t||!e||!r)/*#__PURE__*/return be(Pe,{children:[/*#__PURE__*/Me(E,{onClose:g},"header"),/*#__PURE__*/Me(T,{children:/*#__PURE__*/Me(S,{})}),/*#__PURE__*/Me(U,{children:/*#__PURE__*/Me(I,{})}),/*#__PURE__*/Me(W,{})]});if("sms"===n)return null;if("totp"===n)/*#__PURE__*/return be(Pe,{children:[/*#__PURE__*/Me(E,{backFn:B,onClose:g},"header"),/*#__PURE__*/Me(R,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/Me(Ne,{})}),/*#__PURE__*/Me(P,{children:"Remove authenticator app verification?"}),/*#__PURE__*/be(M,{children:["MFA adds an extra layer of security to your ",r?.name," account. Make sure you have other methods to secure your account."]}),/*#__PURE__*/Me(N,{children:/*#__PURE__*/Me(O,{$warn:!0,onClick:async function(){try{m(void 0),p(!0);let e=await x();return await k({user:e})}catch(e){m(e)}finally{p(!1),o(null)}},loading:w,children:"Remove"})}),/*#__PURE__*/Me(W,{})]});if("passkey"===n){let e=a.mfaEnroll.shouldUnlinkOnUnenrollMfa??!0;/*#__PURE__*/return be(Pe,{children:[/*#__PURE__*/Me(E,{backFn:B,onClose:g},"header"),/*#__PURE__*/Me(R,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/Me(Ne,{})}),/*#__PURE__*/Me(P,{children:"Are you sure you want to remove this passkey?"}),/*#__PURE__*/Me(M,{children:e?"Removing your passkey will remove as both a verification method and a login method.":"Removing your passkey will remove as a verification method."}),/*#__PURE__*/Me(N,{children:/*#__PURE__*/Me(O,{$warn:!0,onClick:async function(){try{m(void 0),p(!0);let e=await D([]);return await k({user:e})}catch(e){m(e)}finally{p(!1),o(null)}},loading:w,children:"Remove"})}),/*#__PURE__*/Me(W,{})]})}return 0!==C.length||K||q||z?"sms"===i?null:"totp"===i&&c?/*#__PURE__*/Me(F,{onClose:g,onReset:B,submitEnrollmentWithTotp:e=>async function(e){try{m(void 0),p(!0);let t=await _(e);return await k({user:t})}catch(e){m(e)}finally{p(!1),o(null)}}(e.mfaCode),error:y,totpInfo:{...c,appName:r?.name||"Privy"}}):"passkey"===i?/*#__PURE__*/Me(L,{onReset:B,onClose:g,submitEnrollmentWithPasskey:G}):/*#__PURE__*/Me(H,{showIntro:!1,userMfaMethods:e.mfaMethods,appMfaMethods:r.mfa.methods,userHasAuthSms:j,onBackToIntro:()=>{},handleSelectMethod:async function(e){m(void 0);try{await v()}catch(e){return void m(e)}return"totp"===e?(l(e),u(null),void b().then((({totpSecret:e,totpAuthUrl:t})=>{u({authUrl:t,secret:e})})).catch((()=>{u(null),B()}))):"passkey"===e&&1===V.length?await G():void l(e)},isTotpLoading:"totp"===i&&!c,isPasskeyLoading:d,error:y,onClose:g,setRemovingMfaMethod:async function(e){m(void 0);try{await v()}catch(e){return void m(e)}o(e)}}):/*#__PURE__*/be(Pe,{children:[/*#__PURE__*/Me(E,{onClose:g},"header"),/*#__PURE__*/Me(R,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/Me(_e,{})}),/*#__PURE__*/Me(P,{children:"Add more security"}),/*#__PURE__*/be(M,{children:[r?.name," does not have any verification methods enabled."]}),/*#__PURE__*/Me(N,{children:/*#__PURE__*/Me(O,{onClick:g,children:"Close"})}),/*#__PURE__*/Me(W,{})]})}},yt=()=>{let e=x(),{setModalData:t}=f(),{verify:r}=wt(),{openModal:a,privy:s,closePrivyModal:n,refreshSessionAndUser:o,setUser:i}=pe();return ie((()=>({enroll:async()=>new Promise(((l,c)=>{t({mfaEnroll:{onSuccess:async e=>{await n({shouldCallAuthOnSuccess:!1,isSuccess:!0}),l(e)},onFailure:async e=>{await n({shouldCallAuthOnSuccess:!1,isSuccess:!1}),c(e)},verify:()=>r({standalone:!1}),shouldUnlinkOnUnenrollMfa:!0,mfaMethods:e.mfa.methods,sendSmsCode:async()=>{throw Error("Not enabled")},enrollSms:async()=>{throw Error("Not enabled")},unenrollSms:async()=>{throw Error("Not enabled")},generateTotpSecret:async()=>await s.fetchPrivyRoute(Ue,{body:{}}),enrollTotp:async e=>{await s.fetchPrivyRoute(Ie,{body:{code:e}});let t=await o();return i(t),t},unenrollTotp:async()=>{await s.fetchPrivyRoute(We,{body:{}});let e=await o();return i(e),e},enrollPasskey:async e=>{await s.fetchPrivyRoute(Re,{body:{credential_ids:e,remove_for_login:!0}});let t=await o();return i(t),t}}}),a(pt)}))})),[s,t,a,n])},mt=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:r,signTypedDataWithCrossAppWallet:a,sendTransactionWithCrossAppWallet:s,signTransactionWithCrossAppWallet:n}=me();return{loginWithCrossAppAccount:({appId:t})=>e({appId:t,action:"login"}),linkCrossAppAccount:({appId:t})=>e({appId:t,action:"link"}),unlinkCrossAppAccount:t,signMessage:r,signTypedData:a,sendTransaction:s,signTransaction:n}};function gt(e){let{sendTransaction:t}=ce(ge);return o("sendTransaction",e),{sendTransaction:t}}function ft(e){let{setWalletPassword:t}=ce(ge);return o("setWalletPassword",e),{setWalletPassword:t}}function At(){let e=x(),t=D(),{client:r,setUser:a,setAuthenticated:s,setIsNewUser:n,initializeWalletProxy:o}=pe(),{create:i}=K();return{createGuestAccount:async()=>{if(!e.id||!r)throw Error("SDK not yet ready");r.startAuthFlow(new q(e.id));try{let l=await r.authenticate(),c=l.user,u=l.isNewUser??!1;if(!c)throw new he("Unable to authenticate guest account");let d=await r.getAccessToken(),h=await o(z);if(d&&h)try{let t=j(c,e.embeddedWallets.ethereum.createOnLogin),r=B(c,e.embeddedWallets.solana.createOnLogin);t&&r?(c=(await i({chainType:"ethereum",latestUser:c})).user,c=(await i({chainType:"solana",latestUser:c})).user):r?c=(await i({chainType:"solana",latestUser:c})).user:t?c=(await i({chainType:"ethereum",latestUser:c})).user:a(c)}catch(e){a(c),console.warn("Unable to create embedded wallet for guest account")}return n(u),s(!0),t("login","onComplete",{user:c,isNewUser:u,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),c}catch(e){throw t("login","onError",e.privyErrorCode||we.UNKNOWN_AUTH_ERROR),e}}}}function kt(e){let{setWalletRecovery:t}=ce(ge);return o("setWalletRecovery",e),{setWalletRecovery:t}}function Ct(e){let{signMessage:t}=ce(ge);return o("signMessage",e),{signMessage:t}}const vt=()=>{let{ready:e,wallets:t}=G(),{user:r}=me(),{rpcConfig:a,chains:s,appId:n}=pe();return{signAuthorization:oe((async(o,i)=>{let l;if(!r)throw Error("User must be authenticated before signing with a Privy wallet");if(!e)throw Error("Wallets are not ready");let c=i?.address??fe(r)?.address??Oe,u=t.find((e=>Fe(e.address)===Fe(c)));if(!u)throw Error("Signing wallet not found.");let d=o.chainId??Number(u.chainId.split(":")[1]);if(0===d)l={chainId:0,address:o.contractAddress,nonce:o.nonce??0};else{let e=s.find((e=>e.id===d));if(!e)throw Error("Error, chain not configured in PrivyProvider config");let t=Le({account:c,chain:e,transport:He(Q(e,a,n))});l=await t.prepareAuthorization({...o})}let h=await u.getEthereumProvider(),w=await h.request({method:"secp256k1_sign",params:[De(l)]});return{...l,...xe(w)}}),[e,t,r,s])}},Et=vt;function Tt(e){let{signTypedData:t}=ce(ge);return o("signTypedData",e),{signTypedData:t}}const St=()=>{let{isModalOpen:e}=ce(ge);return{isOpen:e}};function Ut(e){let{getAccessToken:t}=ce(ge);return o("accessToken",e),{getAccessToken:t}}function It(e){let{authenticated:t,user:r}=me(),{initLoginWithOAuth:a}=pe(),s=D();return o("oAuthAuthorization",e),{reauthorize:e=>Wt(t,r,a,s,e.provider)}}let Wt=async(e,t,r,a,s)=>{if(!e)throw a("linkAccount","onError",we.MUST_BE_AUTHENTICATED,{linkMethod:s}),new he("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(s))))throw new he(`OAuth account of type ${s} not linked to the account.`);await r(s)};function Rt(e){let{client:t}=pe(),[r,a]=ue({status:"initial"});return{linkWithCustomJwt:oe((async r=>{try{a({status:"initial"}),t.startAuthFlow(new J(r)),a({status:"loading"});let{user:s}=await t.link();if(!s)throw Error("Error, user not found");let n=s.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return a({status:"done"}),e?.onSuccess?.({user:s,linkMethod:"custom",linkedAccount:n}),{user:s}}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||we.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),r}}),[t.startAuthFlow,t.link]),state:r}}const bt=e=>{let t=ee();return o("customAuth",e),{status:t}};function Pt({isAuthenticated:e,isLoading:t,...r}){let a=de();le((()=>{t||a.current?.()}),[e,t]);let s=oe((e=>(a.current=e,()=>{a.current=void 0})),[]);return te({...r,subscribe:s})}function Mt(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:r}=me();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:r}}const Nt=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=pe();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},_t=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=(()=>{let{user:e}=me(),t=pe(),{signWithUserSigner:r}=Ae(),a=async({wallet:a,additional_signers:s})=>{let n=await t.client.getAccessToken();if(!e||!n)throw new he("User must be authenticated and have an embedded wallet to delegate actions.");if(!a.id)throw new he("Wallet to add signers to must have ID on server");if(!t.walletProxy)throw new he("Wallet proxy not initialized.");await qe(t.privy,{wallet_id:a.id},r,{additional_signers:s})};return{addSessionSignersInternal:async({address:r,signers:s})=>{let n=await t.client.getAccessToken();if(!e||!n)throw new he("User must be authenticated and have an embedded wallet to add a session signer.");let o=t.walletProxy??await t.initializeWalletProxy(15e3);if(!o)throw new he("Wallet proxy not initialized.");let i=ke(e,r);if(!i)throw new he("Address to add signers too is not associated with current user.");if(Ce(i)){if(0===s.length)throw new he("Must specify at least one signer to add.");let e=[...(await Ke(t.privy,{wallet_id:i.id})).additional_signers,...re(s)];await a({wallet:i,additional_signers:e})}else{if(i.delegated)return{user:e};if(s.length>0)throw new he("Specifying signers in addSessionSigners is only supported for TEE execution and this app uses On-device execution. Pass an empty array for signers instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let a=se({address:r,user:e}),l=ne({address:r,user:e});await t.recoverEmbeddedWallet({address:r}),await o.createDelegatedAction({accessToken:n,rootWallet:l,delegatedWallets:[a]})}let l=await t.refreshSessionAndUser();if(!l)throw Error("Could not refresh user");return{user:l}},removeSessionSignersInternal:async({address:r})=>{let s=await t.client.getAccessToken();if(!e||!s)throw new he("User must be authenticated and have an embedded wallet to delegate actions.");if(!(t.walletProxy??await t.initializeWalletProxy(15e3)))throw new he("Wallet proxy not initialized.");let n=ke(e,r);if(!n)throw new he("Address to remove signers from is not associated with current user.");Ce(n)?await a({wallet:n,additional_signers:[]}):await t.client.revokeDelegatedWallet();let o=await t.refreshSessionAndUser();if(!o)throw Error("Could not refresh user");return{user:o}}}})();return{addSessionSigners:async({address:t,signers:r})=>e({address:t,signers:r}),removeSessionSigners:async({address:e})=>t({address:e})}},Ot=()=>{let{signWithUserSigner:e}=Ae();return ie((()=>({async generateAuthorizationSignature(t){let{signature:r}=await ze(e,t);return{signature:r}}})),[e])},Ft=()=>{let{setUser:e,client:t}=ce(ye),{user:r}=ce(ge);return{user:r,refreshUser:oe((async()=>{let r=await(t?.updateUserAndIdToken());return e(r??null),r}),[t,e])}},Lt=e=>{let t=i(),{initLoginWithTelegram:r,loginWithTelegram:a,telegramAuthState:s,setTelegramAuthState:n}=pe();return{login:oe((async s=>{try{if(t.enabled&&"success"!==t.status)throw new d(t.error,null,we.CAPTCHA_FAILURE);await r(t.token,s?.disableSignup);let{user:n,isNewUser:o,loginAccount:i,wasAlreadyAuthenticated:l}=await a({intent:"login"});e?.onComplete?.({user:n,isNewUser:o,wasAlreadyAuthenticated:l,loginMethod:"telegram",loginAccount:i})}catch(s){throw n({status:"error",error:s}),e?.onError?.(s.privyErrorCode||we.UNKNOWN_AUTH_ERROR),s}}),[r,a,t]),state:s}},Ht=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=pe();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},xt=async({wallet:e})=>{let t=await e.getEthereumProvider();return Ve({address:e.address,sign:async({hash:r})=>{if("privy"!==e.walletClientType)throw new je({error:"Unprefixed signing is not supported by external wallets.",code:"unsupported_wallet_type"});return await t.request({method:"secp256k1_sign",params:[r]})},signMessage:async({message:r})=>await t.request({method:"personal_sign",params:[r,e.address]}),signTypedData:async r=>await t.request({method:"eth_signTypedData_v4",params:[e.address,r]}),signTransaction:async e=>await t.request({method:"eth_signTransaction",params:[e]})})};export{xt as toViemAccount,wt as useAuthMfa,yt as useAuthMfaEnrollment,Ot as useAuthorizationSignature,ht as useBaseAccountSdk,dt as useConnectBaseAccount,ut as useConnectCoinbaseSmartWallet,tt as useConnectOrCreateWallet,mt as useCrossAppAccounts,bt as useCustomAuth,Nt as useDelegatedActions,Mt as useFarcasterSigner,$e as useGetAccessTokenForProvider,At as useGuestAccounts,Ht as useHeadlessDelegatedActions,it as useLinkAccount,Rt as useLinkJwtAccount,Ze as useLinkWithPasskey,rt as useLinkWithSiwe,nt as useLinkWithSiws,Xe as useLoginWithEmail,Ge as useLoginWithFarcasterV2,Qe as useLoginWithOAuth,Ye as useLoginWithPasskey,at as useLoginWithSiwe,st as useLoginWithSiws,et as useLoginWithSms,Lt as useLoginWithTelegram,St as useModalStatus,It as useOAuthTokens,p as usePrivy,Be as useRecoverEmbeddedWallet,gt as useSendTransaction,_t as useSessionSigners,ft as useSetWalletPassword,kt as useSetWalletRecovery,vt as useSign7702Authorization,Et as useSignAuthorization,Ct as useSignMessage,ot as useSignTransaction,Tt as useSignTypedData,Je as useSignupWithPasskey,Pt as useSubscribeToJwtAuthWithFlag,te as useSyncJwtBasedAuthState,Ut as useToken,lt as useUpdateAccount,ct as useUpdateEmail,Ft as useUser,G as useWallets};
